# # ДАННЫЕ, ФУНКЦИИ И МОДУЛИ в Pythton
# #------------------------------------
# # по умолчанию данные в ТЕКСТОВОМ ВИДЕ. Если надо в числах - делаем конвертацию в int

# colors = ['red', 'green', 'blue123'] # источник данных - здесь список
# data = open('file_lec_2.txt', 'a') # связываем текущую переменную с текстовым файлом
# data.writelines(colors) # разделителей не будет / writelines для записи данных
# data.write('\nLINE 125\n')
# data.write('LINE 135\n')
# data.close() # закрыть файл - разорвать подключение файловой переменной с файлом на диске, ч.б.не было утечек памяти. Если не сделать, то может быть ошибка типа: невозможно закрыть...

# # exit() - позволяет не выполнять тот код, который написан ниже


# # или еще способ записи в файл:
# #------------------------------

# with open('file_lec_2.txt', 'w') as data: # as data значит, что конструкцию в начале строки воспринимаем как переменную data
#     data.write('line 10\n')
#     data.write('line 20\n') # здесь не требуется close, будет АВТОМАТИЧЕСКИ разрыв data

# # можно немного изменить:
# #------------------------
# with open('file_lec_2.txt', 'a') as data: # as data значит, что конструкцию в начале строки воспринимаем как переменную data
#     data.write('line 11111\n')
#     data.write('line 22222\n') # здесь не треб...


# чтение данных из файла:
#------------------------

# path = 'file_lec_2.txt'  # path - путь/ создаем путь к папке
# data = open(path, 'r')   # открываем в режиме чтения
# for line in data:        # при помощи цикла проходим по файлу и считываем (выводится в консоль) строки
#     print(line)          # оператор print делает переход на новую строку
# data.close()             # разрываем связь с файлом

# ФУНКЦИИ И МОДУЛИ
# ----------------
# из одного скрипта(файла) использовать функционал другого.
# например, в предыдущей лекции функция: см файл lecture02task002.py
# def f(x):
#     if x == 1:         # можно в одной переменной разные типы использовать (int, float,..)
#         return 'Целое'
#     elif x == 2.3:
#         return 23
#     else:
#         return

# import lecture02task002
# print(lecture02task002.f(1))

# # можно сократить название файла, где записана функция:
# import lecture02task002 as l  # l - сокращенное название, которое задаем
# print(l.f(1))

# # значения ПО УМОЛЧАНИЮ для функций:
# # ---------------------------------

# def new_string(symbol, count):
#     return symbol*count

# print(new_string('!', 5))  # !!!!!
# print(new_string('!'))     # TypeError missing 1 required - передан только 1 аргумент -> ошибка

# # или сделать так:
# def new_string(symbol, count = 3): # задать значение по умолчанию =3, например. Если не указать другое, то сразу будет выводить 3 раза
#     return symbol*count

# print(new_string('!', 5))  # !!!!! т.к. задали новое значение =5
# print(new_string('!'))     # !!! будет по умолчанию 3 раза выводить, count можно не писать
# print(new_string(4))       # 12

# # возможность передачи НЕОГРАНИЧЕННОГО КОЛИЧЕСТВА АРГУМЕНТОВ:
# # ----------------------------------------------------------

# def concatenation(*params):
#     res: str = ""            # четко прописан тип данных - строка. Если нужны числа, то int=0 
#     #res: int=0   # если надо работать с числами, то можно заменить. Но тут склеивание, -> поэтому не нужно
#     for item in params:
#         res += item
#     return res

# print(concatenation('a', 's', 'd', 'w')) # asdw
# print(concatenation('a', '1', 'd', '2')) # a1d2
# #print(concatenation(1, 2, 3, 4)) # TypeError


# # РЕКУРСИЯ  - функция, вызывающая саму себя. Главное-указать когда остановить
# # ---------

# def fib(n):
#     if n in [1, 2]:
#         return 1
#     else:
#         return fib(n-1) + fib(n-2)

# list = []
# for e in range(1, 10):
#     list.append(fib(e))
# print(list)


# # КОРТЕЖИ (tuple ) -  неизменяемый "список" ( )  tuple
# #------------------------------------------------------

# t = ()
# print(type(t))  # tuple

# t = (1,)
# print(type(t))  # tuple  кортеж ИЗ 1 ЭЛЕМЕНТА - ТОЛЬКО С ЗАПЯТОЙ

# t = (1)
# print(type(t))  # int   !!!  - без запятой - просто число и нельзя обратиться по индексу t[0]

# t = (28, 9, 1990)
# print(type(t))  # tuple

# colors = ['red', 'green', 'blue']
# print(colors)    # ['red', 'green', 'blue']  -  СПИСОК [ ]

# t = tuple(colors)
# print(t)         # ('red', 'green', 'blue')  -  КОРТЕЖ ( )

# print(t[0])    # red  - т.е. ОБРАЩАЕМСЯ К ЭЛЕМЕНТУ, как в массиве
# print(t[-1])   # blue - последний элемент, как в списках и строках
# # НО !!! нельзя присвоить значение по индексу: t[0] = 12 -> не получится

# for e in t:    # можно перебирать через циклы
#     print(e)   # red green blue

# t = tuple(['red', 'green', 'blue'])  # список превращаем в кортеж
# red, green, blue = t  # кортеж РАСПАКОВЫВАЕМ и превращаем его в НЕЗАВИСИМЫЕ ПЕРЕМЕННЫЕ
# print('r:{} g:{} b:{}'. format(red, green, blue)) # r:red g:green b:blue


# # СЛОВАРИ { } - неупорядоченные коллекции произвольных объектов с доступом по ключу
# #------------------------------------------------------------------------------

# dictionary = {}   
# dictionary = {      # слэш, ч.б. описывать с новой строки
#         'up' : '^',
#         'left' : '<', 
#         'down' : '|',
#         'right' : '>'
#     }
# print(dictionary) # вывод словаря
# print(dictionary['left'])  # обращение по ключу
#             # типы ключей могут отличаться

# for k in dictionary.keys():   # покажет ключи
#     print(k)   # up left down right

# for k in dictionary.values():   # покажет значения
#     print(k)   # стрелочки

# for k in dictionary:   
#     print(dictionary[k])   # покажет значения (стрелочки в этоим примере)

# dictionary['up'] = 'up_1'  # присвоить новое значение ключу
# print(dictionary['up'])    # up_1


# # МНОЖЕСТВА - содержат в себе уникальные элементы. мы рассматриваем простые неупорядоченные мн-ва. Хотя в Пайтоне можно создать сущность, к-я их упорядочит
# # ------------------------------------------------
# # type - тип данных - set

# colors = {'red', 'green', 'blue'}
# print(type(colors))  # < class 'set' >
# print(colors)   # {'red', 'green', 'blue'}
# colors. add('red')   # попыткадобавить нов.элемент
# print(colors)     # {'red', 'green', 'blue'}  НЕ ДОБАВЛЯЕТСЯ, т.к. уже ЕСТЬ в множестве !!!
# colors. add('gray')   # добавить нов.элемент
# print(colors)     # {'red', 'green', 'blue', 'gray}
# colors.remove('red')  # удалить !!! если эл-та нет, то будет ОШИБКА !!!
# print(colors)     # {'green', 'blue', 'gray}
# colors.discard('red')  # ok - удалить. Даже если эл-та нет, пр-ма НЕ выдаст ошибку !!!
# print(colors)
# colors.clear()   # { }
# print(colors)   # set()

# a = {1, 2, 3, 5, 8}
# b = {2, 5, 8, 13, 21}
# c = a.copy()           # копия \ c = {1, 2, 3, 5, 8}
# u = a.union(b)         # объединение \ u = {1, 2, 3, 5, 8, 13, 21}
# i = a.intersection(b)  # пересечение \ i = {8, 2, 5}
# dl = a.difference(b)   # различие \ dl = {1, 3}
# dr = b.difference(a)   # различие \ dr = {13,21}
# q = a \
#     .union(b) \
#     .difference(a.intersection(b))  # {1, 21, 3, 13}

# print(a)
# print(b)
# print(c)
# print(u)
# print(i)
# print(dl)
# print(dr)
# print(q)

# # неизменяемое(замороженное) множество
# s = frozenset(a)  # НЕИЗМЕНЯЕМОЕ МНОЖЕСТВО (замороженное)


# # некоторые ОСОБЕННОСТИ СПИСКОВ

# list1 = [1, 2, 3, 4, 5]
# list2 = list1

# for e in list1:
#     print(e)     # 1 2 3 4 5

# print()   # пустая строка

# for e in list2:
#     print(e)     # 1 2 3 4 5

# list1[0] = 123

# for e in list1:
#     print(e)     # 123 2 3 4 5

# print()   # пустая строка

# for e in list2:
#     print(e)     # 123 2 3 4 5    !!!!!  тоже поменялось значение [0]

# list2[1] = 333

# for e in list1:
#     print(e)     # 123 333 3 4 5    !!!!!  тоже поменялось значение [1]
    
# print()   # пустая строка

# for e in list2:
#     print(e)     # 123 333 3 4 5

# # ----- и ещё ---

# list1 = [1, 2, 3, 4, 5]
# print(list1)
# print(list1.pop())  # 5 # извлекает последний элемент из списка
# print(list1)

# # удалить любой элемент из списка по индексу:
# print(list1.pop(1))  # 2 # извлекает элемент с индлексом 1 из списка
# print(list1)         # [1, 3, 4] - удалил число 2 (по индексу 1)

# # вставить элемент на нужную позицию:
list3 = [1, 2, 3, 4, 5]
print(list3)
print(list3.insert(2, 11))   # None
print(list3)                 # [1, 2, 11, 3, 4, 5]
# или добавить в конец списка
print(list3.append(22))   # None
print(list3)                 # [1, 2, 11, 3, 4, 5, 22]






